<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Mstdlib-1.0.0: Asynchronous Writer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mstdlib-1.0.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__m__async__writer.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Asynchronous Writer<div class="ingroups"><a class="el" href="group__m__log.html">Logging Subsystem</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf2e6e10a85300528222ec960d6e64a3a"><td class="memItemLeft" align="right" valign="top">typedef M_bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__async__writer.html#gaf2e6e10a85300528222ec960d6e64a3a">M_async_write_cb_t</a> )(char *msg, M_uint64 cmd, void *thunk)</td></tr>
<tr class="separator:gaf2e6e10a85300528222ec960d6e64a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83dc06558f52eff880dd56d057cb3e57"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__async__writer.html#ga83dc06558f52eff880dd56d057cb3e57">M_async_thunk_stop_cb_t</a> )(void *thunk)</td></tr>
<tr class="separator:ga83dc06558f52eff880dd56d057cb3e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d0c979ddaec408ac5bf18aa9a089419"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__async__writer.html#ga5d0c979ddaec408ac5bf18aa9a089419">M_async_thunk_destroy_cb_t</a> )(void *thunk)</td></tr>
<tr class="separator:ga5d0c979ddaec408ac5bf18aa9a089419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga647bf1d171634bdb99aaa8a4943a907a"><td class="memItemLeft" align="right" valign="top">typedef struct M_async_writer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__async__writer.html#ga647bf1d171634bdb99aaa8a4943a907a">M_async_writer_t</a></td></tr>
<tr class="separator:ga647bf1d171634bdb99aaa8a4943a907a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga2050110d5eddd35906ea52dc2917069f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__async__writer.html#ga2050110d5eddd35906ea52dc2917069f">M_async_writer_line_end_mode_t</a> { <br/>
&#160;&#160;<a class="el" href="group__m__async__writer.html#gga2050110d5eddd35906ea52dc2917069fa76c4f2e34cead575fd3498549a6b60f0">M_ASYNC_WRITER_LINE_END_NATIVE</a>, 
<br/>
&#160;&#160;<a class="el" href="group__m__async__writer.html#gga2050110d5eddd35906ea52dc2917069fa12a7de1dc54ca7043b3a1b2a0876a437">M_ASYNC_WRITER_LINE_END_UNIX</a>, 
<br/>
&#160;&#160;<a class="el" href="group__m__async__writer.html#gga2050110d5eddd35906ea52dc2917069fab9b15771c3d0447753bf1763a789af07">M_ASYNC_WRITER_LINE_END_WINDOWS</a>
<br/>
 }</td></tr>
<tr class="separator:ga2050110d5eddd35906ea52dc2917069f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1cce5c3505a55f832fcae8cc508d2bf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__m__async__writer.html#ga647bf1d171634bdb99aaa8a4943a907a">M_async_writer_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__async__writer.html#ga1cce5c3505a55f832fcae8cc508d2bf4">M_async_writer_create</a> (size_t max_bytes, <a class="el" href="group__m__async__writer.html#gaf2e6e10a85300528222ec960d6e64a3a">M_async_write_cb_t</a> write_cb, void *write_thunk, <a class="el" href="group__m__async__writer.html#ga83dc06558f52eff880dd56d057cb3e57">M_async_thunk_stop_cb_t</a> stop_cb, <a class="el" href="group__m__async__writer.html#ga5d0c979ddaec408ac5bf18aa9a089419">M_async_thunk_destroy_cb_t</a> destroy_cb, <a class="el" href="group__m__async__writer.html#ga2050110d5eddd35906ea52dc2917069f">M_async_writer_line_end_mode_t</a> mode)</td></tr>
<tr class="separator:ga1cce5c3505a55f832fcae8cc508d2bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga651721b54a556043c698af0f554007b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__async__writer.html#ga651721b54a556043c698af0f554007b5">M_async_writer_destroy</a> (<a class="el" href="group__m__async__writer.html#ga647bf1d171634bdb99aaa8a4943a907a">M_async_writer_t</a> *writer, M_bool flush)</td></tr>
<tr class="separator:ga651721b54a556043c698af0f554007b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga535ac1cc2e7f922226984bea6680113e"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__async__writer.html#ga535ac1cc2e7f922226984bea6680113e">M_async_writer_destroy_blocking</a> (<a class="el" href="group__m__async__writer.html#ga647bf1d171634bdb99aaa8a4943a907a">M_async_writer_t</a> *writer, M_bool flush, M_uint64 timeout_ms)</td></tr>
<tr class="separator:ga535ac1cc2e7f922226984bea6680113e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02fac912d5bb6cd5cb58f9c6048cf157"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__async__writer.html#ga02fac912d5bb6cd5cb58f9c6048cf157">M_async_writer_start</a> (<a class="el" href="group__m__async__writer.html#ga647bf1d171634bdb99aaa8a4943a907a">M_async_writer_t</a> *writer)</td></tr>
<tr class="separator:ga02fac912d5bb6cd5cb58f9c6048cf157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad18be2e606e2b1fb79cbcbe91be09bdf"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__async__writer.html#gad18be2e606e2b1fb79cbcbe91be09bdf">M_async_writer_is_running</a> (<a class="el" href="group__m__async__writer.html#ga647bf1d171634bdb99aaa8a4943a907a">M_async_writer_t</a> *writer)</td></tr>
<tr class="separator:gad18be2e606e2b1fb79cbcbe91be09bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga689bc303e732f57a30c7d87b7243cd57"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__async__writer.html#ga689bc303e732f57a30c7d87b7243cd57">M_async_writer_is_alive</a> (<a class="el" href="group__m__async__writer.html#ga647bf1d171634bdb99aaa8a4943a907a">M_async_writer_t</a> *writer, M_uint64 timeout_ms)</td></tr>
<tr class="separator:ga689bc303e732f57a30c7d87b7243cd57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2c44c6a297eae3c2a0f24c3bc0c4eb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__async__writer.html#gaf2c44c6a297eae3c2a0f24c3bc0c4eb8">M_async_writer_stop</a> (<a class="el" href="group__m__async__writer.html#ga647bf1d171634bdb99aaa8a4943a907a">M_async_writer_t</a> *writer)</td></tr>
<tr class="separator:gaf2c44c6a297eae3c2a0f24c3bc0c4eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga462b98151cb0092482d600fadb2102e3"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__async__writer.html#ga462b98151cb0092482d600fadb2102e3">M_async_writer_set_command</a> (<a class="el" href="group__m__async__writer.html#ga647bf1d171634bdb99aaa8a4943a907a">M_async_writer_t</a> *writer, M_uint64 write_command, M_bool force)</td></tr>
<tr class="separator:ga462b98151cb0092482d600fadb2102e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03ef80dbf2d9fea2d3c534d4492d4d2b"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__async__writer.html#ga03ef80dbf2d9fea2d3c534d4492d4d2b">M_async_writer_set_command_block</a> (<a class="el" href="group__m__async__writer.html#ga647bf1d171634bdb99aaa8a4943a907a">M_async_writer_t</a> *writer, M_uint64 write_command)</td></tr>
<tr class="separator:ga03ef80dbf2d9fea2d3c534d4492d4d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5f4ad018ea2337b2379a211f5a413eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__async__writer.html#gaf5f4ad018ea2337b2379a211f5a413eb">M_async_writer_set_max_bytes</a> (<a class="el" href="group__m__async__writer.html#ga647bf1d171634bdb99aaa8a4943a907a">M_async_writer_t</a> *writer, size_t max_bytes)</td></tr>
<tr class="separator:gaf5f4ad018ea2337b2379a211f5a413eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeecf314b86ab2738f05d0fd4786c3151"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__async__writer.html#gaeecf314b86ab2738f05d0fd4786c3151">M_async_writer_write</a> (<a class="el" href="group__m__async__writer.html#ga647bf1d171634bdb99aaa8a4943a907a">M_async_writer_t</a> *writer, const char *msg)</td></tr>
<tr class="separator:gaeecf314b86ab2738f05d0fd4786c3151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cb06fa9399d47f0af75a405bf74a262"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__async__writer.html#ga0cb06fa9399d47f0af75a405bf74a262">M_async_writer_get_thunk</a> (<a class="el" href="group__m__async__writer.html#ga647bf1d171634bdb99aaa8a4943a907a">M_async_writer_t</a> *writer)</td></tr>
<tr class="separator:ga0cb06fa9399d47f0af75a405bf74a262"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Helper class that manages an internal worker thread and message queue for asynchrnous writes.</p>
<p>Used internally in various logging modules. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gaf2e6e10a85300528222ec960d6e64a3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef M_bool(* M_async_write_cb_t)(char *msg, M_uint64 cmd, void *thunk)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback that will be called to write messages.</p>
<p>If your program modifies the "thunk" object outside the callback while the writer is running, you'll need to add your own locks inside the callback to make this reentrant.</p>
<p>The command flag allows you to pass one-off notifications to the callback. These notifications will be processed lazily (i.e., the next time the internal thread tries to write something). Only the next write is affected; after the command flag is used once, it's reset to zero.</p>
<p>It is possible for the write callback to be called with a NULL msg and a non-zero command. This happens when the user sets a command with the force flag set to M_TRUE, but the message queue is empty. In this case, the callback should process the command, but it shouldn't write the empty message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>message that needs to be written. Can be modified in-place. May be NULL, for command-only calls. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thunk</td><td>object passed into <em>write_thunk</em> parameter of <a class="el" href="group__m__async__writer.html#ga1cce5c3505a55f832fcae8cc508d2bf4">M_async_writer_create()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>command flag passed into <a class="el" href="group__m__async__writer.html#ga462b98151cb0092482d600fadb2102e3">M_async_writer_set_command()</a>. May be 0, if no command sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if message was consumed, M_FALSE if message should be returned to queue (if possible). </dd></dl>

</div>
</div>
<a class="anchor" id="ga83dc06558f52eff880dd56d057cb3e57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* M_async_thunk_stop_cb_t)(void *thunk)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5d0c979ddaec408ac5bf18aa9a089419"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* M_async_thunk_destroy_cb_t)(void *thunk)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga647bf1d171634bdb99aaa8a4943a907a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct M_async_writer <a class="el" href="group__m__async__writer.html#ga647bf1d171634bdb99aaa8a4943a907a">M_async_writer_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga2050110d5eddd35906ea52dc2917069f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__m__async__writer.html#ga2050110d5eddd35906ea52dc2917069f">M_async_writer_line_end_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Control what type of line endings get automatically appended to error messages. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga2050110d5eddd35906ea52dc2917069fa76c4f2e34cead575fd3498549a6b60f0"></a>M_ASYNC_WRITER_LINE_END_NATIVE</em>&#160;</td><td class="fielddoc">
<p><code>'\n'</code> if running on Unix, <code>'\r\n'</code> if running on Windows </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2050110d5eddd35906ea52dc2917069fa12a7de1dc54ca7043b3a1b2a0876a437"></a>M_ASYNC_WRITER_LINE_END_UNIX</em>&#160;</td><td class="fielddoc">
<p>always use <code>'\n'</code> </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2050110d5eddd35906ea52dc2917069fab9b15771c3d0447753bf1763a789af07"></a>M_ASYNC_WRITER_LINE_END_WINDOWS</em>&#160;</td><td class="fielddoc">
<p>always use <code>'\r\n'</code> </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga1cce5c3505a55f832fcae8cc508d2bf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__m__async__writer.html#ga647bf1d171634bdb99aaa8a4943a907a">M_async_writer_t</a>* M_async_writer_create </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__async__writer.html#gaf2e6e10a85300528222ec960d6e64a3a">M_async_write_cb_t</a>&#160;</td>
          <td class="paramname"><em>write_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>write_thunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__async__writer.html#ga83dc06558f52eff880dd56d057cb3e57">M_async_thunk_stop_cb_t</a>&#160;</td>
          <td class="paramname"><em>stop_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__async__writer.html#ga5d0c979ddaec408ac5bf18aa9a089419">M_async_thunk_destroy_cb_t</a>&#160;</td>
          <td class="paramname"><em>destroy_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__async__writer.html#ga2050110d5eddd35906ea52dc2917069f">M_async_writer_line_end_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a writer object.</p>
<p>The writer does not automatically start running, you must call <a class="el" href="group__m__async__writer.html#ga02fac912d5bb6cd5cb58f9c6048cf157">M_async_writer_start()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_bytes</td><td>maximum bytes that can be queued before messages start getting dropped </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">write_cb</td><td>callback that will be called by an internal thread to write messages </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">write_thunk</td><td>object that can be used to preserve callback state between writes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stop_cb</td><td>optional callback that will be called during a stop request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destroy_cb</td><td>callback that will be used to destroy the thunk when writer is destroyed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>line-end mode for internally generated error messages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga651721b54a556043c698af0f554007b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void M_async_writer_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__async__writer.html#ga647bf1d171634bdb99aaa8a4943a907a">M_async_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_bool&#160;</td>
          <td class="paramname"><em>flush</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy the writer (non-blocking).</p>
<p>This is a non-blocking operation - the worker thread is commanded to destroy itself, then immediately orphaned. The orphaned thread will still try to delete itself, if it has enough time to do so before the process ends. If the program exits before it has time to do this, it will show up as a memory leak (even though it's not).</p>
<p>This call asks the internal thread to stop running at the next opportunity and then destroy the writer object once stopped. If the internal thread has already been stopped, the object is destroyed by the calling thread.</p>
<p>If you set <em>flush</em> to M_TRUE, the internal thread will output all messages in the queue before it destroys itself. Otherwise, the thread will stop itself right after it finishes the current message it's working on, and will output a message describing the number of dropped messages left in the queue before destroying itself.</p>
<p>If the internal thead is frozen, this is effectively a memory leak - the writer object won't be destroyed until the process exits. But the calling thread won't freeze, so this is probably preferable.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__m__async__writer.html#ga535ac1cc2e7f922226984bea6680113e">M_async_writer_destroy_blocking</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">writer</td><td>object we're operating on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flush</td><td>if M_TRUE, output all messages in queue before destroying </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga535ac1cc2e7f922226984bea6680113e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_async_writer_destroy_blocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__async__writer.html#ga647bf1d171634bdb99aaa8a4943a907a">M_async_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_bool&#160;</td>
          <td class="paramname"><em>flush</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint64&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy the writer (blocking, with timeout).</p>
<dl class="section warning"><dt>Warning</dt><dd>This is a BLOCKING operation, it will wait for the worker thread to finish before returning, or for the given timeout to expire (whichever comes first).</dd></dl>
<p>This call asks the internal thread to stop running at the next opportunity and then destroy the writer object once stopped. If the internal thread has already been stopped, the object is destroyed by the calling thread.</p>
<p>If you set <em>flush</em> to M_TRUE, the internal thread will output all messages in the queue before it destroys itself. Otherwise, the thread will stop itself right after it finishes the current message it's working on, and will output a message describing the number of dropped messages left in the queue before destroying itself.</p>
<p>If the timeout expires before the worker thread is done, the worker thread will be orphaned and control will return to the caller (just like in <a class="el" href="group__m__async__writer.html#ga651721b54a556043c698af0f554007b5">M_async_writer_destroy()</a>). The orphaned thread will still try to delete itself, if it has enough time to do so before the process ends. If the program exits before it has time to do this, it will show up as a memory leak (even though it's not).</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__m__async__writer.html#ga651721b54a556043c698af0f554007b5">M_async_writer_destroy</a> </dd>
<dd>
<a class="el" href="group__m__async__writer.html#gaf2c44c6a297eae3c2a0f24c3bc0c4eb8">M_async_writer_stop</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">writer</td><td>object we're operating on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flush</td><td>if M_TRUE, output all messages in queue before destroying </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_ms</td><td>length of time (in milliseconds) to wait until orphaning the worker thread, or 0 for no timeout </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if worker thread finished within timeout, false if it did not and was orphaned </dd></dl>

</div>
</div>
<a class="anchor" id="ga02fac912d5bb6cd5cb58f9c6048cf157"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_async_writer_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__async__writer.html#ga647bf1d171634bdb99aaa8a4943a907a">M_async_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start writing messages from the queue.</p>
<p>This starts an internal worker thread that pulls messages off of the message queue and writes them.</p>
<p>You can stop the worker thread with <a class="el" href="group__m__async__writer.html#gaf2c44c6a297eae3c2a0f24c3bc0c4eb8">M_async_writer_stop()</a> and then restart it with this function, and messages will still be accepted into the message queue the entire time. Start and stop only affect whether messages are being pulled off of the queue and written.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__m__async__writer.html#gaf2c44c6a297eae3c2a0f24c3bc0c4eb8">M_async_writer_stop</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">writer</td><td>object we're operating on </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad18be2e606e2b1fb79cbcbe91be09bdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_async_writer_is_running </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__async__writer.html#ga647bf1d171634bdb99aaa8a4943a907a">M_async_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check to see if writer has been started and is accepting messages.</p>
<p>This is non-blocking, we're just checking whether the writer has been started and not stopped. If you need to check if a running writer is frozen or not, use <a class="el" href="group__m__async__writer.html#ga689bc303e732f57a30c7d87b7243cd57">M_async_writer_is_alive()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">writer</td><td>object we're checking </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if writer has been started, M_FALSE if writer is stopped </dd></dl>

</div>
</div>
<a class="anchor" id="ga689bc303e732f57a30c7d87b7243cd57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_async_writer_is_alive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__async__writer.html#ga647bf1d171634bdb99aaa8a4943a907a">M_async_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint64&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check to see if writer is frozen or not (blocking).</p>
<p>Blocks until either the internal worker thread responds, or the timeout is reached.</p>
<p>If you just want to check if the writer has been started or not, use <a class="el" href="group__m__async__writer.html#gad18be2e606e2b1fb79cbcbe91be09bdf">M_async_writer_is_running()</a> instead, it's non-blocking.</p>
<p>Thread should respond after it finishes with the message that it's currently working on. So, the timeout should be chosen based on the time it takes for the write_cb to execute once (worst case).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">writer</td><td>object we're checking </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_ms</td><td>amount of time to wait for thread to respond (in milliseconds) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if thread responded to liveness check, M_FALSE if thread didn't respond within timeout </dd></dl>

</div>
</div>
<a class="anchor" id="gaf2c44c6a297eae3c2a0f24c3bc0c4eb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void M_async_writer_stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__async__writer.html#ga647bf1d171634bdb99aaa8a4943a907a">M_async_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop internal worker thread.</p>
<dl class="section warning"><dt>Warning</dt><dd>This is a BLOCKING operation, it will wait for the worker thread to finish before returning. The worker thread will stop immediately after it finishes the current message it's working on (if any), so it shouldn't block for long.</dd></dl>
<p>This is used when you need to stop the internal worker thread temporarily, and then restart it with a new thread later. Messages are still accepted into the message queue while the writer is stopped, it just doesn't write anything until <a class="el" href="group__m__async__writer.html#ga02fac912d5bb6cd5cb58f9c6048cf157">M_async_writer_start()</a> is called again.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__m__async__writer.html#ga02fac912d5bb6cd5cb58f9c6048cf157">M_async_writer_start</a> </dd>
<dd>
<a class="el" href="group__m__async__writer.html#ga535ac1cc2e7f922226984bea6680113e">M_async_writer_destroy_blocking</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">writer</td><td>object we're operating on </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga462b98151cb0092482d600fadb2102e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_async_writer_set_command </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__async__writer.html#ga647bf1d171634bdb99aaa8a4943a907a">M_async_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint64&#160;</td>
          <td class="paramname"><em>write_command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_bool&#160;</td>
          <td class="paramname"><em>force</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a command flag that will be passed to the write callback the next time it's called.</p>
<p>This can be used to notify the write callback of a condition change (like a request to rotate logs, etc.).</p>
<p>The command will be passed on the next call to the write callback, then reset immediately afterwards.</p>
<p>If multiple calls to this command occur before the next write, the commands will be OR'd together into one value.</p>
<p>You can force the write callback to always be called after the command is set by setting the <em>force</em> flag to M_TRUE. If not set, the command will be processed the next time the internal worker thread pulls a message off the queue (which might not be until the next call to <a class="el" href="group__m__async__writer.html#gaeecf314b86ab2738f05d0fd4786c3151">M_async_writer_write()</a>, if the queue is currently empty).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">writer</td><td>object we're operating on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">write_command</td><td>flag to pass to write_callback on next write (must be a power of two, or several flags OR'd together) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">force</td><td>if M_TRUE, wakes up writer thread even if message queue is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_FALSE if command rejected due to writer being in the middle of a flush-stop. </dd></dl>

</div>
</div>
<a class="anchor" id="ga03ef80dbf2d9fea2d3c534d4492d4d2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_async_writer_set_command_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__async__writer.html#ga647bf1d171634bdb99aaa8a4943a907a">M_async_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint64&#160;</td>
          <td class="paramname"><em>write_command</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a command flag, and block until that command is processed.</p>
<p>Same as <a class="el" href="group__m__async__writer.html#ga462b98151cb0092482d600fadb2102e3">M_async_writer_set_command()</a>, except that it blocks until the internal worker thread is done processing the command.</p>
<p>Note that this function always sets the force flag for the command - even if the message queue is empty, the internal worker thread will be awakened and the command will be processed. If the message queue is not empty, the command will be processed when the next message is pulled off of the queue.</p>
<dl class="section warning"><dt>Warning</dt><dd>If this function is called from multiple threads on the same async_writer object, execution of the requested commands will be serialized - the command from the second thread won't even start until after the command from the first thread has finished.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">writer</td><td>object we're operating on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">write_command</td><td>flag to pass to write_callback on next write (must be a power of two, or several flags OR'd together) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_FALSE if command rejected due to writer being in the middle of a flush-stop. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf5f4ad018ea2337b2379a211f5a413eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void M_async_writer_set_max_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__async__writer.html#ga647bf1d171634bdb99aaa8a4943a907a">M_async_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the maximum buffer size.</p>
<p>If the writer is running, the new maximum buffer size will not actually be enforced until the next time a message is written to the writer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">writer</td><td>object we're operating on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_bytes</td><td>new maximum number of bytes that can be queued before messages start getting dropped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaeecf314b86ab2738f05d0fd4786c3151"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_async_writer_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__async__writer.html#ga647bf1d171634bdb99aaa8a4943a907a">M_async_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a message to the writer (non-blocking).</p>
<p>The message will be added to a work queue, to be passed later to write_callback by an internal worker thread.</p>
<p>If the message can't be added (empty message, message itself is larger than queue, alloc error, or writer is in the middle of a flush-stop) the message is dropped without modifying the internal queue.</p>
<p>If the queue doesn't have enough empty space to fit the message, messages in the queue are dropped until there is enough room. The oldest message is dropped first, then the next oldest, and so on, until there's enough room in the queue to add the new message.</p>
<p>Note that an async writer will still accept messages passed with this function when stopped - it will just add them to the message queue, and wait until the writer is started again to write them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">writer</td><td>object we're operating on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>message to add to write queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if message was added to queue, M_FALSE if it couldn't be added </dd></dl>

</div>
</div>
<a class="anchor" id="ga0cb06fa9399d47f0af75a405bf74a262"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* M_async_writer_get_thunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__async__writer.html#ga647bf1d171634bdb99aaa8a4943a907a">M_async_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the internal writer callback thunk.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the writer is running, don't modify the thunk from external code unless you've implemented your own locking scheme between the writer callback and the external code, using locks stored in the thunk.</dd>
<dd>
Ownership of the returned thunk remains with the M_async_writer_t object, so this pointer is only valid until <a class="el" href="group__m__async__writer.html#ga651721b54a556043c698af0f554007b5">M_async_writer_destroy()</a> is called.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">writer</td><td>object we're operating on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to internal </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Dec 13 2017 22:34:55 for Mstdlib-1.0.0 by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
